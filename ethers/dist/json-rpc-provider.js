"use strict";var d=Object.defineProperty;var M=Object.getOwnPropertyDescriptor;var w=Object.getOwnPropertyNames;var R=Object.prototype.hasOwnProperty;var P=(r,n)=>{for(var a in n)d(r,a,{get:n[a],enumerable:!0})},A=(r,n,a,s)=>{if(n&&typeof n=="object"||typeof n=="function")for(let t of w(n))!R.call(r,t)&&t!==a&&d(r,t,{get:()=>n[t],enumerable:!(s=M(n,t))||s.enumerable});return r};var K=r=>A(d({},"__esModule",{value:!0}),r);var I={};P(I,{JsonRpcProvider:()=>h});module.exports=K(I);var p=require("@moonup/moon-types"),m=require("ethers");var T=require("@ethersproject/abstract-signer"),y=require("@ethersproject/bytes"),u=require("@ethersproject/hash"),c=require("@ethersproject/properties"),i=require("ethers"),e=class r extends T.Signer{constructor(n,a){super(),(0,c.defineReadOnly)(this,"_isSigner",!0),(0,c.defineReadOnly)(this,"provider",a),this.MoonSignerConfig=n,this.SDK=n.SDK}_signTypedData(n,a,s){throw new Error("Method not implemented.")}updateConfig(n){this.SDK=n.SDK,this.MoonSignerConfig=n}connect(n){return new r(this.MoonSignerConfig,n)}async signTypedData(n,a,s){return(await this.SDK.getAccountsSDK().signTypedData(this.MoonSignerConfig.address,{data:JSON.stringify({domain:n,types:a,value:s})}).then(o=>{if(!o.ok)throw new Error(o.statusText);return o.data.data})).signed_message||""}async getAddress(){return this.MoonSignerConfig.address}async signMessage(n){let a=new Uint8Array((0,y.arrayify)((0,u.hashMessage)(n)));return(await this.SDK.getAccountsSDK().signMessage(this.MoonSignerConfig.address,{data:a.toString(),encoding:"utf-8"}).then(t=>{if(!t.ok)throw new Error(t.statusText);return t.data.data})).signed_message||""}async broadcastTransaction(n){let a=await this.SDK.getAccountsSDK().broadcastTx(this.MoonSignerConfig.address,{rawTransaction:n,chainId:this.MoonSignerConfig.chainId});if(!a.ok)throw new Error(a.statusText);return a.data.data.transaction_hash||""}async sendTransaction(n){let a=await this.populateTransaction(n);console.log("Moon::sendTransaction: populateTransaction",a);let s=await this.signTransaction(a);console.log("Moon::sendTransaction: signedRawTx",s);let t=await this.broadcastTransaction(s||"");console.log("Moon::sendTransaction: broadcastTx res",t);let o=await this.provider?.getTransaction(t||"");return console.log("Moon::sendTransaction: txResponse",o),o||{}}transactionRequestToInputBody(n){return{chain_id:i.BigNumber.from(n.chainId).toString(),data:n.data&&n.data?.toString()||"",to:n.to,gasPrice:i.BigNumber.from(n.gasPrice).toString(),gas:i.BigNumber.from(n.gasLimit).toString(),nonce:i.BigNumber.from(n.nonce).toString(),value:n.value!==void 0?i.BigNumber.from(n.value).toString():void 0,encoding:"utf-8"}}moonTransactionResponseToTransactions(n){return n.transactions||[]}async signTransaction(n){return await this.SDK.getAccountsSDK().signTransaction(this.MoonSignerConfig.address,this.transactionRequestToInputBody(n)).then(s=>{if(!s.ok)throw new Error(s.statusText);return this.moonTransactionResponseToTransactions(s.data.data)?.at(0)?.raw_transaction})||""}async getTypedDataDomain(n,a,s,t){return{name:n,version:a,chainId:s,verifyingContract:t}}async getTypedData(n,a,s){return{domain:n,types:a,message:s}}};var f=require("@ethersproject/bytes"),D=require("@ethersproject/hash"),g=require("ethers"),S=r=>{let n=r.filter(s=>!g.utils.isAddress(s))[0];return new Uint8Array((0,f.arrayify)((0,D.hashMessage)(n)))},l=r=>{let n=r.filter(a=>!g.utils.isAddress(a))[0];return typeof n=="string"?JSON.parse(n):n};var h=class{constructor(n){this.config=n,this.chainId=n.chainId;let a=(0,p.getRpcUrls)(this.chainId).pop()||"";this.sdk=n.SDK,this.http=new m.providers.JsonRpcProvider(a),this.signer=new e({SDK:this.sdk,address:n.address,chainId:this.chainId.toString()})}async request(n){switch(n.method){case"eth_requestAccounts":return(await this.sdk.listAccounts()).keys||[];case"personal_sign":if(Array.isArray(n.params)&&n.params.length>0){let t=S(n?.params);return await this.signer.signMessage(t)}else throw new Error("request.params is undefined or not an array");case"eth_signTypedData":if(Array.isArray(n.params)&&n.params.length>0){let t=l(n?.params);return await this.signer.signTypedData(t.domain,t.types,t.value)||""}else throw new Error("request.params is undefined or not an array");case"eth_sendTransaction":let s=n?.params&&Array.isArray(n?.params)&&n?.params[0]?n?.params[0]:void 0;if(s)return await this.signer.sendTransaction(s);throw new Error("eth_sendTransaction error");default:return await this.http.send(n.method,n.params||[])}}updateConfig(n){this.chainId=n.chainId,this.sdk=n.SDK,this.http=new m.providers.JsonRpcProvider((0,p.getRpcUrls)(this.chainId).pop()||""),this.signer.updateConfig({SDK:this.sdk,address:"",chainId:this.chainId.toString()})}};0&&(module.exports={JsonRpcProvider});
//# sourceMappingURL=json-rpc-provider.js.map